---
title: "Tablas GT y Spotify"
author: "RLadies BA"
date: '2022-07-30'
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      warning = FALSE, 
                      message = FALSE, 
                      code_folding=TRUE,
                      align='center')

options(scipen=999)

color_spotify = "#1DB954"
```

# 1. Librer√≠as

Se definen los paquetes üì¶ a utilizar:

```{r}
library(tidyverse) # Manipulaci√≥n de datos
library(gt)        # Tablas gt: grammar of tables
library(gtExtras)  # Extras de tablas gt
library(spotifyr)  # API de spotify
library(gtrendsR)  # Google trends API
library("rjson")
```

## 2. API Spotify - Credenciales

Se cuenta con un archivo **(credentials..json)**, que contiene las siguientes variables obtenidas de la p√°gina de desarrolladores de Spotify:

-   SPOTIFY_CLIENT_ID

-   SPOTIFY_CLIENT_SECRET

El formato del archivo **credentials.json** est√° incluido en el .gitignore del repositorio. Esto permite mantener las credenciales an√≥nimas (sin publicar en repositorios), dado que son personales y no deben compartirse. A continuaci√≥n se muestra el formato de este archivo:

```{r, eval=FALSE}
{
  "SPOTIFY_CLIENT_ID" : "SPOTIFY_CLIENT_ID",
  "SPOTIFY_CLIENT_SECRET" : "SPOTIFY_CLIENT_SECRET"

}
```

Se realiza la lectura de las credenciales mediante la funci√≥n fromJSON(). Luego, se setean como variables de entorno:

```{r}
credentials <- fromJSON(file = "credentials.json")

Sys.setenv(SPOTIFY_CLIENT_ID = credentials$SPOTIFY_CLIENT_ID)
Sys.setenv(SPOTIFY_CLIENT_SECRET = credentials$SPOTIFY_CLIENT_SECRET)
```

Se utiliza la funci√≥n **get_spotify_access_token**() del paquete {**spotifyr**} üì¶para autenticarse a la API\>

```{r}
access_token <- get_spotify_access_token()
```

Para verificar que la autenticaci√≥n haya sido exitosa, se realiza una consulta de los artistas m√°s escuchados:

```{r, eval=FALSE}
tabla_user <- get_my_top_artists_or_tracks(
    type = 'artists', 
    time_range = 'short_term', #'short_term', # 'medium_term', 'long_term' 
    limit = 10) %>%
  select(name, genres) %>%
  rowwise() %>%
  mutate(genres = paste(genres, collapse = ', ')) %>%
  ungroup %>%
  gt()
```

# Caso: an√°lisis de un artista particular

Se define el artista a utilizar:

```{r}
ARTISTA = 'bad bunny'
```

Para este artista, se genera una b√∫squeda de variables:

```{r}
vars_audio = c(
  'danceability', 'energy', 'loudness', 'acousticness', 'instrumentalness'
)
```

```{r, eval=FALSE}
tracks_features <- get_artist_audio_features(artist = ARTISTA) %>%
  
  select(
    artist_id, artist_name, album_id, album_name,
    album_release_date, album_images, track_name, duration_ms,

    # Variables vinculadas al audio:
    all_of(vars_audio)       
  ) %>% 
  
  arrange(desc(album_release_date))
```

```{r}
# tracks_features %>% saveRDS('tracks_features.rds')
tracks_features <- readRDS('tracks_features.rds')
```

Se cuenta con un df de variables vinculadas a cada canci√≥n de cada √°lbum del artista seleccionado:

```{r}
tracks_features %>% 
  glimpse()
```

# 3. The grammar of tables (gt)

## 3.1 Intro a gt

```{r}
tabla <- tracks_features %>% 
  head() %>% 
  select(artist_name, album_name, all_of(vars_audio)) %>% 
  gt()
```

```{r, eval=FALSE}
tabla
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla, 'tablas/tabla_1.png', vwidth = 2000, vheight = 3000)
```

```{r}
knitr::include_graphics('tablas/tabla_1.png')
```

Notar que las variables num√©ricas aparecen con muchos decimales. Una forma sencilla de arreglar esto en {gt} es la siguiente. En este caso, dejando 4 decimales para visualizar la variable instrumentalness:

```{r, eval=FALSE}
tabla %>% 
  fmt_number(columns = where(is.numeric), decimals=4)
```

## 3.2 Tabla a nivel √°lbumes

Se agregan los datos a nivel de cada √°lbum. Notar que, en el caso de las variables de audio, se decidi√≥ convertirlas en una lista (N observaciones num√©ricas que representan cada una de las canciones incluidas en el √°lbum). En los pr√≥ximos pasos se explicar√° el por qu√© de la decisi√≥n:

```{r}
df_albums <- tracks_features %>%
  
  group_by(
    album_images, artist_name, album_id, album_name, album_release_date
  ) %>%
  
  summarise(
    # Duraci√≥n del √°lbum: suma de duraci√≥n de cada canci√≥n
    duration_mins = sum(duration_ms/(1000*60)),
    
    # Lista de cada variable de audio
    across(all_of(vars_audio), ~ list(.x)),
  ) %>% 
  
  ungroup()
```

```{r}
tabla_albums <- df_albums %>% 
  select(-album_images) %>% 
  gt() 
```

```{r, eval=FALSE}
tabla_albums
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums, 'tablas/tabla_2.png', vwidth = 2000, vheight = 3000)
```

```{r}
knitr::include_graphics('tablas/tabla_2.png')
```

## 3.3 Im√°genes en tablas gt

Se quiere a√±adir la imagen del √°lbum. Para ello, se construye la siguiente funci√≥n. Para cada √°lbum se cuenta con distintos tama√±os de im√°genes, donde cada imagen se encuentra representada por un url. Se decide seleccionar la imagen de tama√±o=64, extrayendo el url:

```{r}
get_imagen = function(album_images){
  album_images %>% 
    data.frame() %>% 
    filter(height==64) %>% 
    pull(url) %>% 
    as.character()
}
```

Se aplica la funci√≥n al dataframe. Para ello, se utiliza la funci√≥n **map()** del paquete {purrr} üì¶:

```{r}
df_albums <- df_albums %>% 
  mutate(album_images = map(album_images, ~get_imagen(album_images=.x))) %>% 
  distinct()
```

Para visualizar los urls como imagenes, se utiliza la funci√≥n **text_transform()** de {gt}. Adem√°s, la funci√≥n **tab_header()** permite a√±adir t√≠tulo y subt√≠tulo.

```{r}
tabla_albums <- df_albums %>%  select(-album_id) %>% 

  gt() %>% 
  
  tab_header(
    title = md(glue::glue('**{str_to_title(ARTISTA)}** en Spotify')),
    subtitle = '√Ålbumes m√°s recientes'
  ) %>% 
  
  text_transform(
    locations = cells_body(columns = c(album_images)),
    fn = function(album_images) {
      lapply(album_images, web_image, height = 50)
    }
  ) 
```

```{r, eval=FALSE, echo=FALSE, layout='l-page'}
tabla_albums %>% cols_hide(all_of(vars_audio))
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums %>% cols_hide(all_of(vars_audio)), 
  'tablas/tabla_3.png', vwidth = 2000, vheight = 3000)

knitr::include_graphics('tablas/tabla_3.png')
```

Otra funci√≥n √∫til para visualizar este tipo de informaci√≥n es **gt_merge_stack()** que permite concatenar dos variables en una √∫nica:

```{r}
tabla_albums <- tabla_albums %>%  

  gt_merge_stack(
    col1 = album_name, 
    col2 = artist_name) 
```


```{r, eval=FALSE}
tabla_albums %>% cols_hide(all_of(vars_audio)) 
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums %>% cols_hide(all_of(vars_audio)), 
  'tablas/tabla_4.png', vwidth = 2000, vheight = 3000)

knitr::include_graphics('tablas/tabla_4.png')
```


Para visualizar las variables de audio, se utilizar√°n algunas funcionalidades del paquete {gtExtras} üì¶: 

```{r}
tabla_albums <- tabla_albums %>% 
  
  gt_color_box(columns = duration_mins, 
               palette=c('white', color_spotify), 
               domain=c(0,round(max(df_albums$duration_mins))+1)) %>% 
  
  gt_plt_dist(column = danceability, 
              type = "density", line_color = "black", 
              fill_color = color_spotify) %>% 
  
  gt_plt_dist(column = energy, 
              type = "density", line_color = "black", 
              fill_color = color_spotify) %>% 
  
  gt_plt_dist(column = loudness,
              type = "density", line_color = "black", 
              fill_color = color_spotify) %>% 
  
  gt_plt_dist(column = acousticness,
              type = "boxplot", line_color = "black", 
              fill_color = color_spotify)

```

```{r, eval=FALSE}
tabla_albums %>% cols_hide('instrumentalness')
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums %>% cols_hide('instrumentalness'),
  'tablas/tabla_5.png', vwidth = 2000, vheight = 3000)

knitr::include_graphics('tablas/tabla_5.png')
```

## 3.4 GGplot en gt

Notar que si se agregara el boxplot para el caso de la variable instrumentalness, se observa, para todos los √°lbumes, distribuciones con valores at√≠picos:

```{r, eval=FALSE}
tabla_albums %>%
  gt_plt_dist(column = instrumentalness,
              type = "boxplot", line_color = "black", 
              fill_color = color_spotify) 
```

Por esta raz√≥n, se utilizar√° el caso de esta variable para explicar c√≥mo se podr√≠a identificar a estos valores at√≠picos mediante el uso de {ggplot2} üì¶

```{r}
gen_outliers_plots<- function(.df, .variable, .font_size=22, .lwd=3){
  temp <- .df %>% 
    select(all_of(c('track_name',.variable))) %>% 
    pivot_longer(cols=-track_name) 
  
  track <- temp %>% 
    slice(which.max(value)) %>% 
    pull(track_name)
  
  temp %>% 
    mutate(is_outlier=ifelse(track_name==track, track_name, NA)) %>% 
    ggplot(aes(y=value, x=name)) + 
    geom_boxplot(
      fill=color_spotify, width=0.2, lwd=.lwd, outlier.size=5
    ) + 
    ggrepel::geom_text_repel(aes(label=is_outlier), 
      na.rm=TRUE, nudge_x=0.4, size=.font_size)+
    coord_flip()+
    theme_void()
}
```

Realizando la prueba de la funci√≥n, se observa el gr√°fico que genera: 

```{r}
gen_outliers_plots(
  .df=tracks_features %>% filter(album_name=='X 100PRE'), 
  .variable='instrumentalness', .font_size=10, .lwd = 0.5)
```

Ahora se incluyen estos plots en la tabla. Primero, se mappea la funci√≥n al df: 

```{r}
df_albums <- df_albums %>% 
  mutate(instrumentalness=map(
    album_id, ~gen_outliers_plots(
      .df=tracks_features %>% filter(album_id==.x), 
      .variable='instrumentalness'
    )
  ))
```

Se visualiza la tabla completa:

```{r}
tabla_albums <- tabla_albums %>% 
  
    text_transform(
    locations = cells_body(columns = instrumentalness),
    fn = function(x) {
      map(
        df_albums$instrumentalness,
        gt::ggplot_image,
        height = px(60),
        aspect_ratio = 2
      )
    }
  ) 
```

```{r, eval=FALSE}
tabla_albums
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums,
  'tablas/tabla_6.png', vwidth = 2000, vheight = 3000)

knitr::include_graphics('tablas/tabla_6.png')
```



## Formato


```{r}
tabla_albums <- tabla_albums %>% 
  
  gt::tab_spanner(label='Un tipo de variables', 
                  columns=danceability:loudness) %>% 
  gt::tab_spanner(label='Otro tipo de variables', 
                  columns = c('acousticness','instrumentalness')) %>% 
  
  gt::tab_footnote(
    locations=cells_column_labels('duration_mins'), 
    footnote='Duraci√≤n en minutos = suma de la duraci√≥n de cada una de las canciones que componen el √°lbum.') %>% 
  
  gt::tab_footnote(
    locations=cells_column_labels('instrumentalness'), 
    footnote='En el caso de instrumentalness, al existir valores muy at√≠picos se muestra la canci√≥n a la que corresponde el m√°ximo valor en cada √°lbum.') %>% 
  
  gt::tab_source_note(source_note='Fuente: API de Spotify') %>% 
  
  cols_label(
    album_images = '',
    album_name = '',
    album_release_date = 'Lanzamiento',
    duration_mins = 'Duraci√≥n',
    danceability = 'Danceability üï∫',
    energy = 'Energy ‚ú®',
    loudness = 'Loudness üîä',
    acousticness = 'Acousticness üéπ',
    instrumentalness = 'Instrumentalness üéº'
  )  
```

```{r, eval=FALSE}
tabla_albums
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums,
  'tablas/tabla_7.png', vwidth = 2000, vheight = 3000)

knitr::include_graphics('tablas/tabla_7.png')
```

Adem√°s, se a√±ade un theme espec√≠fico para asignarle colores y formatos adicionales: 

```{r}
my_theme <- function(gt_object, ...){
  gt_object %>%
    tab_options(
      column_labels.background.color = "#39423c",
      footnotes.background.color = "#39423c",
      source_notes.background.color = "#39423c",
      heading.background.color = "#39423c",
      heading.align = "left",
      ...
    ) %>%
    tab_style(
      style = cell_text(color = color_spotify, size = px(32)),
      locations = cells_title("title")
    )
}
```

```{r}
tabla_albums <- tabla_albums %>% 
    my_theme()
```

```{r, eval=FALSE}
tabla_albums
```

```{r, eval=TRUE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_albums, 'tablas/tabla_8.png', 
           vwidth = 2000, vheight = 3000)

knitr::include_graphics('tablas/tabla_8.png')
```

```{r}
knitr::knit_exit()
```


# Tendencias

Se utiliza la API de Google trends para obtener la evoluci√≥n de las b√∫squedas realizadas para un √°lbum:

```{r}
ALBUM = 'LAS QUE NO IBAN A SALIR'
RELEASE_DATE = '2020-05-10'

trends <- gtrends(
  keyword = paste0(ARTISTA, ' ', tolower(ALBUM)),
  geo = "",
  time = "all"
)

```

Visualmente:

```{r}
trends %>%
  .$interest_over_time %>% 
  mutate(hits = ifelse(str_detect(hits, "<"),0,hits)) %>% 
  mutate(hits = as.numeric(hits)) %>% 
  ggplot(aes(x = date, y = hits)) +
  geom_line(colour = "darkblue", size = 0.7) +
  facet_wrap(~keyword) +
  theme_minimal()
```

Se genera una funci√≥n para realizar este gr√°fico:

```{r}
gen_trend_ggplot <- function(.album, .artista, .release_date) {
  if (tolower(.album) == tolower(.artista)) {
    .album = 'self titled'
  }
  
  gtrends(
    keyword = paste0(.artista, ' ', .album),
    geo = "",
    time = "today+5-y"
  ) %>%
    .$interest_over_time %>%
    mutate(hits = ifelse(str_detect(hits, "<"), 0, hits)) %>%
    mutate(hits = as.numeric(hits)) %>%
    ggplot(aes(x = date, y = hits)) +
    geom_line(color = "darkblue", size = 1) +
    geom_vline(xintercept = as.POSIXct(.release_date),
               color = 'red') +
    annotate(
      geom = 'text',
      x = as.POSIXct(.release_date) - lubridate::days(500),
      y = 90,
      size = 6,
      label = paste0('Publicaci√≥n'),
      color = 'red'
    ) +
    geom_curve(
      aes(
        x = as.POSIXct(.release_date) - lubridate::days(500) ,
        y = 85,
        xend = as.POSIXct(.release_date),
        yend = 75
      ),
      curvature = 0.3,
      angle = 40,
      color = 'red',
      size = 1,
      arrow = arrow(length = unit(0.3, "cm"))
    ) +
    labs(x = '', y = '%') +
    theme_minimal() +
    theme(axis.text = element_text(size = 14),
          title = element_text(size = 16))
}

```

```{r}
p <- gen_trend_ggplot(.album = ALBUM,
                 .artista = ARTISTA,
                 .release_date = RELEASE_DATE)

p 
```

# Tabla con ggplots

Se aplica esta funci√≥n sobre los √°lbumes de la tabla:

```{r, eval=FALSE}
tabla_plots <- tabla_album %>%  
  
  # Seleccionando los 5 √°lbumes m√°s recientes, para no hacer tantas consultas a la API (podr√≠a dar error):
  arrange(desc(album_release_date)) %>% 
  
  head(5) %>% 
  
  mutate(evolucion = map2(
    album_name, album_release_date,
    ~gen_trend_ggplot(.album =.x, 
                      .artista=ARTISTA, 
                      .release_date=.y)))
  

```

Visualizando la tabla final:

```{r, eval=FALSE}
tabla_final <- tabla_plots %>% 
  
 gt() %>% 
  
  text_transform(
    locations = cells_body(columns = c(album_images)),
    fn = function(album_images) {
      lapply(album_images, web_image, height = 50)
    }
  ) %>%
  
  cols_label(album_images = '') %>% 
    
  # Ggplots en formato gr√°fico (sino aparecen como texto)
  text_transform(
    locations = cells_body(columns = evolucion),
    fn = function(x) {
      map(
        tabla_plots$evolucion,
        gt::ggplot_image,
        height = px(180),
        aspect_ratio = 2
      )
    }
  ) %>% 
  
  fmt_number(columns=where(is.numeric))
```

```{r, eval=FALSE, echo=FALSE, layout='l-page'}
gt::gtsave(tabla_final, 'tabla_final.png', 
           vwidth = 2000, vheight = 3000)
```

```{r}
knitr::include_graphics('tabla_final.png')
```
